spritePaths = '''./Buildings/Artilery2.bmp
./Buildings/ArtlFire.bmp
./Buildings/Base.bmp
./Buildings/Build1.bmp
./Buildings/Build2.bmp
./Buildings/Build3.bmp
./Buildings/Build4.bmp
./Buildings/Build5.bmp
./Buildings/Build6.bmp
./Buildings/Build7.bmp
./Buildings/BuildingBottom.bmp
./Buildings/Creation.bmp
./Buildings/Creatn2a.bmp
./Buildings/Creatn2b.bmp
./Buildings/Cube.bmp
./Buildings/Factory2.bmp
./Buildings/Factory3.bmp
./Buildings/Field.bmp
./Buildings/Generator.bmp
./Buildings/MinerAni.bmp
./Buildings/MinerDst.bmp
./Buildings/MinerShd.bmp
./Buildings/MinerTop.bmp
./Buildings/Module.bmp
./Buildings/Platform.bmp
./Buildings/Random.bmp
./Buildings/Silo.bmp
./Buildings/StarDest.bmp
./Buildings/Starport.bmp
./Buildings/Starprt2.bmp
./Buildings/Storage1.bmp
./Buildings/Televatr.bmp
./Buildings/Televtr2.bmp
./Buildings/TradPlat.bmp
./Buildings/Turret.bmp
./Buildings/Wall.bmp
./Buildings/WallDest.bmp
./Interface/BuyButtn.bmp
./Interface/Dialog2.bmp
./Interface/Dialog3.bmp
./Interface/Dialogue.bmp
./Interface/Exit.lbm.bmp
./Interface/grid.bmp
./Interface/InfoEmbs.bmp
./Interface/IntButn2.bmp
./Interface/IntButtn.bmp
./Interface/IntfcBuy.bmp
./Interface/IntInfo.bmp
./Interface/IntOptn2.bmp
./Interface/Intrfac3.bmp
./Interface/Intrfac4.bmp
./Interface/Intrface.bmp
./Interface/Intrface2.bmp
./Interface/Mission.bmp
./Interface/MsnChoos.bmp
./Interface/MsnChs2.bmp
./Misc/ArtlFlsh.bmp
./Misc/Blood1.bmp
./Misc/Bullet.1.bmp
./Misc/Bullet2.bmp
./Misc/Bullets.bmp
./Misc/Cloud1.bmp
./Misc/Cloud2.bmp
./Misc/Cloud3.bmp
./Misc/Cursor1.bmp
./Misc/Dark.bmp
./Misc/Electric.bmp
./Misc/Embossed.bmp
./Misc/exploBig.bmp
./Misc/explosn.bmp
./Misc/expSmall.bmp
./Misc/Face1.bmp
./Misc/Flag.bmp
./Misc/Flame.bmp
./Misc/Font.bmp
./Misc/Icons.bmp
./Misc/Junk.bmp
./Misc/Marker.bmp
./Misc/Mines.bmp
./Misc/Muzzle.bmp
./Misc/Objects.bmp
./Misc/Outline.bmp
./Misc/Outline2.bmp
./Misc/Selected.bmp
./Misc/Teleport.bmp
./Misc/Teleprt2.bmp
./Misc/Test1.bmp
./Misc/Test2.bmp
./Misc/Test3.bmp
./Misc/Test4.bmp
./Terrain/Cave.bmp
./Terrain/Cliffmask.bmp
./Terrain/Crater.bmp
./Terrain/Crtr2Lav.bmp
./Terrain/Crtr2Wtr.bmp
./Terrain/CrtrJnt.bmp
./Terrain/CrtrMisc.bmp
./Terrain/CrtrRDst.bmp
./Terrain/CrtrRoad.bmp
./Terrain/GrasClif.bmp
./Terrain/GrasRoad.bmp
./Terrain/Grass.bmp
./Terrain/Grass2.bmp
./Terrain/GrassRDst.bmp
./Terrain/Grs2CrtB.bmp
./Terrain/Grs2Crtc.bmp
./Terrain/Grs2Crtr.bmp
./Terrain/Grs2Mnt.bmp
./Terrain/Grs2Watr.bmp
./Terrain/Grss2Lav.bmp
./Terrain/GrssCrtr.bmp
./Terrain/GrssMisc.bmp
./Terrain/Ice2Snow.bmp
./Terrain/Ice2Watr.bmp
./Terrain/IceBrk1.bmp
./Terrain/IceBrk2.bmp
./Terrain/IceDent.bmp
./Terrain/IceRDest.bmp
./Terrain/IceRoad.bmp
./Terrain/Icicle.bmp
./Terrain/Icicle2.bmp
./Terrain/Icicle3.bmp
./Terrain/Lava.bmp
./Terrain/LavaBubl.bmp
./Terrain/LavaFlow.bmp
./Terrain/LavaRDest.bmp
./Terrain/LavaRoad.bmp
./Terrain/Mnt2Crtb.bmp
./Terrain/Mnt2Crtc.bmp
./Terrain/Mnt2Crtr.bmp
./Terrain/Mnt2Lava.bmp
./Terrain/Mnt2Sand.bmp
./Terrain/Mnt2Watr.bmp
./Terrain/MntCliff.bmp
./Terrain/MntMisc.bmp
./Terrain/MntRDst.bmp
./Terrain/MntRoad.bmp
./Terrain/Mountains.bmp
./Terrain/Road.bmp
./Terrain/RoadDest.bmp
./Terrain/RoadJnt.bmp
./Terrain/RoadSnw2.bmp
./Terrain/Rock.bmp
./Terrain/Rock2.bmp
./Terrain/Sand.bmp
./Terrain/Sand2Lav.bmp
./Terrain/SandCrtr.bmp
./Terrain/SandMisc.bmp
./Terrain/SandRDst.bmp
./Terrain/SandRoad.bmp
./Terrain/Sn2-2Crb.bmp
./Terrain/Sn2-2Crc.bmp
./Terrain/Sn2-2Wtr.bmp
./Terrain/Sn2-Clif.bmp
./Terrain/Sn2-RDst.bmp
./Terrain/Sn22Crtr.bmp
./Terrain/Snd2Crtb.bmp
./Terrain/Snd2Crtc.bmp
./Terrain/Snd2Crtr.bmp
./Terrain/Snd2Watr.bmp
./Terrain/SndCliff.bmp
./Terrain/Snow.bmp
./Terrain/Snow2.bmp
./Terrain/Snw2-Ct2.bmp
./Terrain/Snw2-Ctr.bmp
./Terrain/Snw2-Lav.bmp
./Terrain/Snw2-Rck.bmp
./Terrain/Snw2-Rck2.bmp
./Terrain/Snw2-Rck3.bmp
./Terrain/Snw2Crtb.bmp
./Terrain/Snw2Crtc.bmp
./Terrain/Snw2Crtr.bmp
./Terrain/Snw2Lav.bmp
./Terrain/Snw2Mnt.bmp
./Terrain/Snw2Watr.bmp
./Terrain/SnwCliff.bmp
./Terrain/SnwCratr.bmp
./Terrain/Stn2Crtb.bmp
./Terrain/Stn2Crtc.bmp
./Terrain/Stn2Crtr.bmp
./Terrain/Stn2Lav.bmp
./Terrain/Stn2SnwB.bmp
./Terrain/Stn2Watr.bmp
./Terrain/StnCliff.bmp
./Terrain/StnCratr.bmp
./Terrain/Stne2Snw.bmp
./Terrain/StneRoad.bmp
./Terrain/StnMisc.bmp
./Terrain/StnRDst.bmp
./Terrain/StnRock1.bmp
./Terrain/StnRock2.bmp
./Terrain/Stone.bmp
./Terrain/Swamp.bmp
./Terrain/SwmpAni.bmp
./Terrain/SwmpBubl.bmp
./Terrain/SwmpPlnt.bmp
./Terrain/SwmpRDst.bmp
./Terrain/SwmpRoad.bmp
./Terrain/SwmpRock.bmp
./Terrain/Tch2CrtB.bmp
./Terrain/Tch2Crtc.bmp
./Terrain/Tch2Crtr.bmp
./Terrain/Tch2Lava.bmp
./Terrain/Tch2Watr.bmp
./Terrain/TchCliff.bmp
./Terrain/Tech.bmp
./Terrain/TechMsc1.bmp
./Terrain/TechRDst.bmp
./Terrain/TechRoad.bmp
./Terrain/TreeAsh.bmp
./Terrain/TreeGrs.bmp
./Terrain/Trees.bmp
./Terrain/Water.bmp
./Terrain/Water2.bmp
./Terrain/WatrFlow.bmp
./Terrain/WatrRDst.bmp
./Terrain/WatrRoad.bmp
./Vehicles/Artil.bmp
./Vehicles/Artil2.bmp
./Vehicles/Artil3.bmp
./Vehicles/Artl3Shd.bmp
./Vehicles/Balloon1.bmp
./Vehicles/Beast.bmp
./Vehicles/Boat1.bmp
./Vehicles/Boat2.bmp
./Vehicles/Boat3.bmp
./Vehicles/Builder1.bmp
./Vehicles/Builder2.bmp
./Vehicles/Builder3.bmp
./Vehicles/Builder4.bmp
./Vehicles/Builder5.bmp
./Vehicles/Copter.bmp
./Vehicles/Copter2.bmp
./Vehicles/Copter2a.bmp
./Vehicles/Copter2b.bmp
./Vehicles/CptrShd1.bmp
./Vehicles/CptrShd2.bmp
./Vehicles/Crow.bmp
./Vehicles/Gull.bmp
./Vehicles/Mech.bmp
./Vehicles/Miner.bmp
./Vehicles/Mother.bmp
./Vehicles/Mother2.bmp
./Vehicles/Mother2B.bmp
./Vehicles/Mother2c.bmp
./Vehicles/Scout1.bmp
./Vehicles/Scout2.bmp
./Vehicles/SeaMnstr.bmp
./Vehicles/Seed.bmp
./Vehicles/SeedShad.bmp
./Vehicles/Shadow.bmp
./Vehicles/Ship1.bmp
./Vehicles/Ship2.bmp
./Vehicles/Ship3.bmp
./Vehicles/Tank1.bmp
./Vehicles/Tank10.bmp
./Vehicles/Tank11.bmp
./Vehicles/Tank12.bmp
./Vehicles/Tank13.bmp
./Vehicles/Tank14.bmp
./Vehicles/Tank15.bmp
./Vehicles/Tank16.bmp
./Vehicles/Tank2.bmp
./Vehicles/Tank3.bmp
./Vehicles/Tank3Shd.bmp
./Vehicles/Tank4.bmp
./Vehicles/Tank5.bmp
./Vehicles/Tank5A.bmp
./Vehicles/Tank5b.bmp
./Vehicles/Tank5c.bmp
./Vehicles/Tank5d.bmp
./Vehicles/Tank6.bmp
./Vehicles/Tank7.bmp
./Vehicles/Tank8.bmp
./Vehicles/Tank9.bmp
./Vehicles/TankB1.bmp
./Vehicles/TankB2.bmp
./Vehicles/TankBase.bmp
./Vehicles/TnkTurt1.bmp
./Vehicles/TnkTurt2.bmp
./Vehicles/Transprt.bmp'''

spritePaths = '''./Terrain/Cave.bmp
./Terrain/Crater.bmp
./Terrain/GrasRoad.bmp
./Terrain/Grass.bmp
./Terrain/Grs2Watr.bmp
./Terrain/GrssCrtr.bmp
./Terrain/GrssMisc.bmp'''

mapData = '''a=./Terrain/Grass.bmp=0
b=./Terrain/Grass.bmp=1
c=./Terrain/Grass.bmp=2
d=./Terrain/Grass.bmp=3
e=./Terrain/Grass.bmp=4
f=./Terrain/Grass.bmp=5
g=./Terrain/Grass.bmp=6
h=./Terrain/Grass.bmp=7
i=./Terrain/Grass.bmp=8
j=./Terrain/GrasRoad.bmp=1
k=./Terrain/GrasRoad.bmp=11
l=./Terrain/GrasRoad.bmp=25
m=./Terrain/GrasRoad.bmp=8
n=./Terrain/GrasRoad.bmp=7
o=./Terrain/GrasRoad.bmp=0
p=./Terrain/GrasRoad.bmp=2
q=./Terrain/GrasRoad.bmp=25
r=./Terrain/GrasRoad.bmp=24
s=./Terrain/GrasRoad.bmp=18
t=./Terrain/GrasRoad.bmp=17
abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeeojjjjjjjjjjjjjjjjjjpeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeentkkkkkkkkkkkkkkkksmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeenmeeeeeeeeeef
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjqrjjjjjjjjjjjjjjjjlmeeeeeeeeeef
kkkkkkkkkkkkkkkkkkkkkkkkkkkkkstkkkkkkkkkkkkkkkkkteeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeeeeeeeeeeeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeenrjjjjjjjjjjjjjjjjjjeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeekkkkkkkkkkkkkkkkkksmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeef
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeenmeeeeeeeeeef
ghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnmhhhhhhhhhhi'''

class Misc
  @CURRENCY = "$"
  @SPRITE_DIR = 'data/images/'
  @BUILDING_ANIM_INTERVAL = 100

  @addons: () ->
    String::endsWith = (suffix) ->
      @indexOf(suffix, @length - suffix.length) isnt -1

  @move: (obj, [x, y]) ->
    obj.css
      position: 'absolute'
      top: y
      left: x

  @snapToGrid: (x, y) ->
      sz = 40
      x = Math.floor(x / sz) * sz
      y = Math.floor(y / sz) * sz
      [x, y]

  @snapToTerrain: (x, y) ->
      sz = 20
      x = Math.floor(x / sz) * sz
      y = Math.floor(y / sz) * sz
      [x, y]

  @displayError: (msg) ->
    target = $("#alerts")
    target.find(".alert").remove()
    d = HTML.div(msg).addClass("alert").addClass("alert-danger")
    target.append(d)
    
  @displayMessage: (msg) ->
    target = $("#alerts")
    target.find(".alert").remove()
    d = HTML.div(msg).addClass("alert").addClass("alert-success")
    target.append(d)

  @copy: (ar) ->
    ar.slice()

  @getTime: () ->
    new Date().getTime()

  @addRotateAnimateToJQuery: () ->
    # http://stackoverflow.com/questions/15191058/css-rotation-cross-browser-with-jquery-animate
    $.fn.animateRotate = (startrad, rad, duration, easing, complete) ->
      args = $.speed(duration, easing, complete)
      step = args.step
      @each (i, e) ->
        args.complete = $.proxy(args.complete, e)
        args.step = (now) ->
          Misc.rotate(e, startrad + now)
          #$.style e, "transform", "rotate(" + now + "deg)"
          step.apply e, arguments  if step

        $(deg: 0).animate
          deg: rad - startrad
        , args

  @rotate: (container, rad) ->
    container = $(container)
    oleft = container.width() / 2
    otop = container.height() / 2
    rotate = "rotate(#{rad}rad)"
    origin = "#{oleft}px #{otop}px"
    props =
      "transform": rotate
      "-webkit-transform": rotate
      "-moz-transform": rotate
      "-ms-transform": rotate
      "transform-origin": origin
      "-webkit-transform-origin": origin
      "-moz-transform-origin": origin
      "-ms-transform-origin": origin
    container.css(props)

class ImageSprite
   
  @cloneCanvas = (oldCanvas) ->
    
    #create a new canvas
    newCanvas = document.createElement("canvas")
    context = newCanvas.getContext("2d")
    
    #set dimensions
    newCanvas.width = oldCanvas.width
    newCanvas.height = oldCanvas.height
    
    #apply the old canvas to the new one
    context.drawImage oldCanvas, 0, 0
    
    #return the new canvas
    newCanvas

  @transparents = []
  @transparents.push
    r: 0x00
    g: 0x8a
    b: 0x76
  @transparents.push
    r: 0x40
    g: 0x60
    b: 0x80
  @transparents.push
    r: 0x45
    g: 0x4e
    b: 0x5b
  @transparents.push
    r: 0x80
    g: 0x74
    b: 0x79
  @transparents.push
    r: 0x2f
    g: 0x48
    b: 0x61
  @transparents.push
    r: 0x00
    g: 0xFF
    b: 0x00

  @getPixel: (pixels, x, y) ->
    colorsize = pixels.data.length / (pixels.height * pixels.width)
    i = (y * pixels.width + x) * colorsize
    rgba =
      r: pixels.data[i]
      g: pixels.data[i+1]
      b: pixels.data[i+2]
      a: pixels.data[i+3]

  @setPixel: (pixels, x, y, rgba) ->
    colorsize = pixels.data.length / (pixels.height * pixels.width)
    i = (y * pixels.width + x) * colorsize
    pixels.data[i] = rgba.r
    pixels.data[i+1] = rgba.g
    pixels.data[i+2] = rgba.b
    pixels.data[i+3] = rgba.a

  @isTransparent: (pixels, rgb) ->
    #for transparent, i in @transparents
    #  if rgb.r == transparent.r && rgb.g == transparent.g && rgb.b == transparent.b
    #    return true
    #return false
    transparent = @getPixel(pixels, 1, 0) # guesswork, works for most sprites
    rgb.r == transparent.r && rgb.g == transparent.g && rgb.b == transparent.b

  @bfs: ([px, py], id, pixels, components) ->
    transparent = @getPixel(pixels, 0, 0)
    isTransparent = (rgb) ->
      rgb.r == transparent.r && rgb.g == transparent.g && rgb.b == transparent.b
    colorsize = pixels.data.length / (pixels.height * pixels.width)
    neighbours = []
    for x in [-1,0,1]
      for y in [-1,0,1]
        if x != 0 || y != 0
          neighbours.push([x, y])
    queue = []
    queue.push([px, py])
    component =
      id: id
      positions: []
    while queue.length > 0
      [x, y] = queue.pop()
      rgb = @getPixel(pixels, x, y)
      if not @isTransparent(pixels, rgb)
        component.positions.push([x, y])
        components[x][y] = component
        for n in neighbours
          newX = x + n[0]
          newY = y + n[1]
          if newX >= 0 && newY >= 0 && newX < pixels.width && newY < pixels.height
            if not components[newX][newY]?
              queue.push([newX, newY])
    component


  @getParts: (texture) ->
    # load image in first canvas
    myCanvas = document.createElement("canvas")
    myCanvas.width = texture.width
    myCanvas.height = texture.height
    [width, height] = [texture.width, texture.height]
    myCanvasContext = myCanvas.getContext("2d") # Get canvas 2d context
    myCanvasContext.drawImage texture, 0, 0 # Draw the texture
    pixels = myCanvasContext.getImageData(0, 0, width, height) # Read the texels/pixels back      
    colorsize = pixels.data.length / (pixels.height * pixels.width)

    # create 2nd canvas for target image
    createCanvas = (width, height) ->
      newCanvas = document.createElement("canvas")
      newCanvas.width = width
      newCanvas.height = height
      newCanvasContext = newCanvas.getContext("2d")
      newPixels = newCanvasContext.getImageData(0, 0, width, height)
      ret =
        canvas: newCanvas
        canvasContext: newCanvasContext
        newPixels: newPixels

    components = []
    for x in [0..width-1]
      c = new Array(height)
      components[x] = c

    id = 0
    componentByID = {}
    for y in [0..height-1]
      for x in [0..width-1]
        pixel = ImageSprite.getPixel(pixels, x, y)
        if not ImageSprite.isTransparent(pixels, pixel) and not components[x][y]?
          component = ImageSprite.bfs([x, y], id, pixels, components)
          componentByID[id] = component
          id += 1

    canvases = []
    canvases.json_components = []
    for id of componentByID
      component = componentByID[id]
      minX = Number.MAX_VALUE
      minY = Number.MAX_VALUE
      maxX = 0
      maxY = 0
      if component.positions.length > 1
        for pos in component.positions
          minX = Math.min(minX, pos[0])
          minY = Math.min(minY, pos[1])
          maxX = Math.max(maxX, pos[0])
          maxY = Math.max(maxY, pos[1])
        component.minX = minX
        component.minY = minY
        component.maxX = maxX
        component.maxY = maxY
        component.width = 1 + maxX - minX
        component.height = 1 + maxY - minY
        canvases.json_components.push
          minX: minX
          minY: minY
          maxX: maxX
          maxY: maxY
        canvasRet = createCanvas(component.width, component.height)
        for pos in component.positions
          rgba = ImageSprite.getPixel(pixels, pos[0], pos[1])
          ImageSprite.setPixel(canvasRet.newPixels, pos[0] - minX, pos[1] - minY, rgba)
        canvasRet.canvasContext.putImageData(canvasRet.newPixels, 0, 0)
        canvas = canvasRet.canvas
        canvases.push(canvas)

    canvases

class AnimatedSprite

  constructor: (canvases) ->
    @container = HTML.div()
    @canvases = canvases
    @i = 0

  clone: () ->
    @newCanvases = (ImageSprite.cloneCanvas(i) for i in @canvases)
    @newAnim = new AnimatedSprite(@newCanvases)
    @newAnim.animate()
    @newAnim

  animateHelper: () ->
    @container.empty()
    @container.append(@canvases[@i])
    @i += 1
    @i = @i % @canvases.length

  animate: (interval=150) ->
    ams = @
    @loopTime = @canvases.length * interval
    setInterval (() -> ams.animateHelper()), interval


class DebugHVAnimSprite
  constructor: (imgsrc, animationIndices, interval, callback) ->
    sprite = @
    texture = new Image()
    texture.onload = () ->
      @canvases = ImageSprite.getParts(texture)
      callback(sprite)
    texture.src = imgsrc
 
class HVAnimSprite

  constructor: (imgsrc, animationIndices, interval, callback) ->
    sprite = @
    imgsrc = Misc.SPRITE_DIR + imgsrc
    if callback
      texture = new Image()
      texture.onload = () ->
        canvases = ImageSprite.getParts(texture)
        c2 = []
        for i in animationIndices
          c2.push(canvases[i])
        sprite.canvases = c2
        sprite.anim = new AnimatedSprite(sprite.canvases)
        sprite.anim.animate(interval)
        sprite.container = sprite.anim.container
        callback(sprite)
      texture.src = imgsrc
    @imgsrc = imgsrc
    @interval = interval
    @animationIndices = animationIndices

  clone: () ->
    n = new HVAnimSprite(@imgsrc, @animationIndices, @interval)
    n.canvases = []
    for c in @canvases
      n.canvases.push(ImageSprite.cloneCanvas(c))
    n.anim = new AnimatedSprite(n.canvases)
    n.anim.animate(@interval)
    n.container = n.anim.container
    n

  scale: (width, height) ->
    for c in @canvases
      $(c).css
        width: width
        height: height
    
class Explosion extends HVAnimSprite

  constructor: (callback) ->
    @imgsrc = 'Misc/expSmall.bmp'
    @animationIndices = [0..6]
    @interval = 150
    super(@imgsrc, @animationIndices, @interval, callback)

class BigExplosion extends HVAnimSprite

  constructor: (callback) ->
    @imgsrc = 'Misc/exploBig.bmp'
    @animationIndices = [0..13]
    @interval = 150
    super(@imgsrc, @animationIndices, @interval, callback)

class  extends HVAnimSprite

  constructor: (callback) ->
    @imgsrc = 'Buildings/base.bmp'
    @animationIndices = [0,0,0,0,0,1,2,3,2,1,0,0,0,0,0]
    @interval = 150
    super(@imgsrc, @animationIndices, @interval, callback)

class Creation2AAnim extends HVAnimSprite

  constructor: (callback) ->
    @imgsrc = 'Buildings/Creatn2a.bmp'
    @animationIndices = [0,1,2,3,4,9,8,7,6,5,10,11,12,13,14]
    @interval = 150
    super(@imgsrc, @animationIndices, @interval, callback)

class Factory2Anim extends HVAnimSprite

  constructor: (callback) ->
    @imgsrc = 'Buildings/Factory2.bmp'
    @animationIndices = [0,1,2,3,4,5,7,8,9,10,9,8,7,5,4,3,2,1]
    @interval = 50
    super(@imgsrc, @animationIndices, @interval, callback)

class SelectSpriteAll

  constructor: (imgsrc, index, callback) ->
    @container = HTML.div()
    sprite = @
    imgsrc = Misc.SPRITE_DIR + imgsrc
    @imgsrc = imgsrc
    texture = new Image()
    texture.onload = () ->
      canvases = ImageSprite.getParts(texture)
      sprite.json =
        components: canvases.json_components
      sprite.handlers = []
      sprite.links = []
      for c, i in canvases
        $(c).css
          width: c.width * 2
          height: c.height * 2
        link = HTML.a c,
          href: "#" + imgsrc
          title: i
        do (c, i) ->
          sprite.handlers[i] = (ev) ->
            $("#selectedSprite")
              .empty()
              .append(ImageSprite.cloneCanvas(c))
              .data("sprite", sprite)
              .data("index", i)
          link.click sprite.handlers[i]
        sprite.links.push(link)
        sprite.container.append(link)
      sprite.canvas = canvases[index]
      sprite.canvases = canvases
      callback(sprite)
    texture.src = imgsrc

  reattachHandlers: () ->
    for h, i in @handlers
      @links[i].click h

  getFixedSprite: (index) ->
    fs = new FixedSprite(@imgsrc, index)
    fs.canvases = (ImageSprite.cloneCanvas(x) for x in @canvases)
    fs.canvas = ImageSprite.cloneCanvas(@canvas)
    fs.container.append(fs.canvases[index])
    fs

class FixedSprite
  
  constructor: (imgsrc, index, callback) ->
    @imgsrc = imgsrc
    @index = index
    @container = HTML.div()
    imgsrc = Misc.SPRITE_DIR + imgsrc
    if callback?
      texture = new Image()
      sprite = @
      texture.onload = () ->
        canvases = ImageSprite.getParts(texture)
        if not canvases[index]?
          throw "incorrect sprite index #{index} for #{imgsrc}"
        sprite.canvases = canvases
        sprite.canvas = canvases[index]
        sprite.container.append(sprite.canvas)
        callback(sprite)
      texture.src = imgsrc

  setIndex: (index) ->
    @container.empty()
    @container.append(@canvases[index])

  clone: () ->
    fs = new FixedSprite(@imgsrc, @index)
    fs.canvases = (ImageSprite.cloneCanvas(x) for x in @canvases)
    fs.canvas = ImageSprite.cloneCanvas(@canvas)
    fs.container.append(fs.canvas)
    fs

class BuyItem
  constructor: () ->
    @container = HTML.div()
    @container.addClass("buymenu-item")
    @costContainer = HTML.div()
    @costContainer.css "text-align", "center"
    @container.css "width", @sprite.canvas.width + 15
    @container.append(@sprite.canvas)
    @container.append(@costContainer)
    @updateCost(@cost)

  updateCost: (cost) ->
    @cost = cost
    @costContainer.html(@cost + Misc.CURRENCY)

  createInstance: () ->
    @mapSprite.clone()

class BuyFactory2 extends BuyItem

  constructor: (sprites) ->
    @sprite = sprites.factory
    @cost = 200
    @damage = 25
    @fireRate = 100
    @range = 100
    @startRotation = 0
    @mapSprite = sprites.mapFactory
    super()

class BuyArtillery2 extends BuyItem

  constructor: (sprites) ->
    @sprite = sprites.artillery
    @cost = 500
    @damage = 50
    @fireRate = 500
    @range = 250
    @startRotation = Math.PI / 4 #3 * Math.PI / 8
    @mapSprite = sprites.mapArtillery
    super()

class BuyGenerator extends BuyItem

  constructor: (sprites) ->
    @sprite = sprites.generator
    @cost = 800
    @damage = 50
    @fireRate = 100
    @range = 250
    @startRotation = 0
    @mapSprite = sprites.mapGenerator
    super()

class BuyField extends BuyItem

  constructor: (sprites) ->
    @sprite = sprites.field
    @cost = 5000
    @damage = 500
    @fireRate = 100
    @range = 500
    @startRotation = Math.PI / 4 #3 * Math.PI / 8
    @mapSprite = sprites.mapField
    super()




class Direction
  constructor: (spriteIndex, radians) ->
    @spriteIndex = spriteIndex
    @radians = radians

class DirectionIndices
  @m = Math.PI / 8
  @directions =
    TopLeft: new Direction(0, 3*@m)
    TopMid: new Direction(1, 2*@m)
    TopRight: new Direction(2, 1*@m)
    MidLeft: new Direction(3, 4*@m)
    MidRight: new Direction(4, 0*@m)
    BottomLeft: new Direction(5, 5*@m)
    BottomMid: new Direction(6, 6*@m)
    BottomRight: new Direction(7, 7*@m)

  @rad2index: (rad) ->
    while rad < 0
      rad += 2 * Math.PI
    while rad > 2 * Math.PI
      rad -= 2 * Math.PI
    mindist = Number.MAX_VALUE
    mindir = undefined
    for name, dir of @directions
      dist = Math.abs(rad - dir.radians)
      if dist < mindist
        mindist = dist
        mindir = dir.spriteIndex
    mindir

class BulletSprite extends FixedSprite

  constructor: (callback) ->
    @imgsrc = 'Misc/Bullets.bmp'
    @rotation = 3 * Math.pi / 8
    super(@imgsrc, 1, callback)

class Artillery2Sprite extends FixedSprite
 
  constructor: (callback) ->
    @imgsrc = 'Buildings/Artilery2.bmp'
    super(@imgsrc, 0, callback)

class Factory2Sprite extends FixedSprite
 
  constructor: (callback) ->
    @imgsrc = 'Buildings/Factory2.bmp'
    super(@imgsrc, 1, callback)

class GrassSprite extends FixedSprite
 
  constructor: (index, callback) ->
    @imgsrc = 'Terrain/Grass.bmp'
    super(@imgsrc, index, callback)

class DirectedSprite extends FixedSprite

class MotherSprite extends FixedSprite

  constructor: (callback) ->
    @imgsrc = 'Vehicles/Mother.bmp'
    super(@imgsrc, 0, callback)

class Bullet
  constructor: (sprite) ->
    @container = HTML.div()
    @container.append(sprite.container)

class Creep

  constructor: (gameState, sprite, speed, health, path, prize) ->
    @gameState = gameState
    @sprite = sprite
    @speed = speed
    @path = path
    @health = health
    @maxHealth = health
    @prize = prize
    @active = false
    @container = HTML.div()
    healthBar = HTML.div()
    healthBarSub = HTML.div()
    healthBar.append(healthBarSub)
    healthBarSub.css "height", "100%"
    healthBar
      .css "background", "black"
      .css "width", sprite.canvas.width
      .css "height", "5px"
      .css "border", "1px solid black"
    @healthBar = healthBar
    @healthBarSub = healthBarSub
    @updateHealth(health)
    @container.append(healthBar)
    @container.append(sprite.canvas)

  midX: () ->
    @pos.x + @container.width() / 2

  midY: () ->
    @pos.y + @container.height() / 2

  remove: () ->
    @container.empty()
    sprite =
      if @sprite.canvas.width > 20
        @gameState.sprites.bigExplosion
      else
        @gameState.sprites.smallExplosion
    newSprite = sprite.clone()
    newSprite.scale @sprite.canvas.width, @sprite.canvas.height
    @container.append(newSprite.container)
    container = @container
    setTimeout (() -> container.remove()), newSprite.anim.loopTime
    @active = false
    @dead = true

  updateHealth: (health) ->
    oldHealth = @health
    @health = health
    if health <= 0 and oldHealth > 0
      @gameState.winPrize(@prize)
      @remove()
    else if @health <= 0.2 * @maxHealth
      @healthBarSub.css "background", "red"
    else if @health <= 0.5 * @maxHealth
      @healthBarSub.css "background", "yellow"
    else
      @healthBarSub.css "background", "green"
    @healthBarSub.css "width", Math.round(@health * 100 / @maxHealth) + "%"

class Tower

  constructor: (gameState, [x, y, width, height], startRotation, sprite, fireRate, damage, range) ->
    @container = HTML.div()
    @container.append(sprite.container)
    @container
        .css('position', 'absolute')
        .css('left', x)
        .css('top', y)
    @sprite = sprite
    @pos =
      x: x
      y: y
    @width = width
    @height = height
    @fireRate = fireRate
    @damage = damage
    @range = range
    @lastFire = gameState.getGameTime()
    @startRotation = startRotation
    @currentRotation = 0

  midX: () ->
    @pos.x + @width / 2.0

  midY: () ->
    @pos.y + @height / 2.0

class BuyActive
  constructor: (buyItem, cursorImage) ->
    @buyItem = buyItem
    @cursorImage = cursorImage
    $(cursorImage).addClass("buyItem-cursorImage")

class BuyMenu

  createActive: (buyItem) ->
    sprite = buyItem.sprite
    cursor = HTML.div().addClass("circle").addClass("buyItem-cursor")
    cursor
      .css
        width: buyItem.range
        height: buyItem.range
    canvas = ImageSprite.cloneCanvas(sprite.canvas)
    cursor.canvas = canvas
    cursor.append(canvas)
    $(canvas)
      .css
        position: "absolute"
        left: buyItem.range / 2 - sprite.canvas.width / 2
        top: buyItem.range / 2 - sprite.canvas.height / 2

    buyActive = new BuyActive(buyItem, cursor)

  constructor: (gameState, callback) ->
    buyMenu = @
    @container = HTML.div()
    bar = @container

    sprites = gameState.sprites
   
    buyActives = []

    buyActives.push(@createActive(new BuyFactory2(sprites)))
    buyActives.push(@createActive(new BuyArtillery2(sprites)))
    buyActives.push(@createActive(new BuyGenerator(sprites)))
    buyActives.push(@createActive(new BuyField(sprites)))

    for buyActive in buyActives
      buyItem = buyActive.buyItem
      bar.append(buyItem.container)
      buyItem.container.click do (buyActive) -> () -> buyMenu.setActive buyActive

    buyMenu.setActive(buyActives[0])


    @moneyContainer = HTML.div().addClass("money")
    bar.append(@moneyContainer)
  
  setActive: (buyActive) ->
    @active = buyActive
    $(".buymenu-item.active").removeClass("active")
    @hideCursor()
    @showCursor()
    $(buyActive.buyItem.container).addClass("active")

  showCursor: () ->
    if @active?
      $(@active.cursorImage).css("visibility", "visible")

  hideCursor: () ->
    $(".buyItem-cursorImage").css("visibility", "hidden")

  updateMoney: (money) ->
    @moneyContainer.html("Cash: " + money + Misc.CURRENCY)

  setupMouseHandlers: (map, gameState) ->
    buyMenu = @
    getCoords = (map, event, cursor) ->
      x = event.pageX - map.offset().left - cursor.width() / 2
      y = event.pageY - map.offset().top - cursor.height() / 2
      [x, y] = Misc.snapToGrid(x, y)
    map.on "mousemove", (event) ->
      if buyMenu.active?
        map.css "cursor", "none"
        map.append(buyMenu.active.cursorImage)
        buyMenu.showCursor()
        cursor = buyMenu.active.cursorImage
        [x, y] = getCoords($(this), event, cursor)
        cursor
          .css
            position: 'absolute'
            left: x
            top: y
    map.on "mouseout", (event) ->
      buyMenu.hideCursor()
    map.click (event) ->
      if buyMenu.active?
        cursor = buyMenu.active.cursorImage
        [x, y] = getCoords($(this), event, cursor)
        x += cursor.width() / 2 - cursor.canvas.width / 2
        y += cursor.height() / 2 - cursor.canvas.height / 2
        gameState.buy(buyMenu, [x, y])

class Map
  
  constructor: (gameState, mapWidth, mapHeight) ->
    terrain = []
    @terrain = terrain

    sprites = gameState.sprites

    sprite = sprites.grassTopLeft.clone()
    Misc.move $(sprite.container), [0, 0]
    terrain.push(sprite.container)

    sprite = sprites.grassTopRight.clone()
    Misc.move $(sprite.container), [mapWidth - sprite.canvas.width, 0]
    terrain.push(sprite.container)

    sprite = sprites.grassBottomLeft.clone()
    Misc.move $(sprite.container), [0, mapHeight - sprite.canvas.height]
    terrain.push(sprite.container)

    sprite = sprites.grassBottomRight.clone()
    Misc.move $(sprite.container), [mapWidth - sprite.canvas.width, mapHeight - sprite.canvas.height]
    terrain.push(sprite.container)

    sprite = sprites.grassTopMid
    for x in [1..(mapWidth / sprite.canvas.width) - 2]
      clone = sprite.clone()
      terrain.push(clone.container)
      Misc.move $(clone.container), [x*sprite.canvas.width, 0]
    
    sprite = sprites.grassMidLeft
    for y in [1..(mapHeight / sprite.canvas.height) - 2]
      clone = sprite.clone()
      terrain.push(clone.container)
      Misc.move $(clone.container), [0, y*sprite.canvas.height]
 
    sprite = sprites.grassMidRight
    for y in [1..(mapHeight / sprite.canvas.height) - 2]
      clone = sprite.clone()
      terrain.push(clone.container)
      Misc.move $(clone.container), [mapWidth - sprite.canvas.width, y*sprite.canvas.height]

    sprite = sprites.grassBottomMid
    for x in [1..(mapWidth / sprite.canvas.width) - 2]
      clone = sprite.clone()
      terrain.push(clone.container)
      Misc.move $(clone.container), [x*sprite.canvas.width, mapHeight - sprite.canvas.height]

    sprite = sprites.grassMidMid.clone()
    for x in [1..(mapWidth / sprite.canvas.width)-2]
      for y in [1..(mapHeight / sprite.canvas.height)-2]
        clone = sprite.clone()
        terrain.push(clone.container)
        Misc.move $(clone.container), [x*sprite.canvas.width, y*sprite.canvas.height]

class Wave

class Wave1 extends Wave
  constructor: (sprites) ->
    @count = 5
    @speed = 10.0 / 100
    @interval = 1500
    @health = 200
    @prize = 20
    @sprite = sprites.beast

class Wave2 extends Wave
  constructor: (sprites) ->
    @count = 15
    # pixels per millisecond
    @speed = 5.0 / 100
    @interval = 2000
    @health = 500
    @prize = 50
    @sprite = sprites.tank5

class Wave3 extends Wave
  constructor: (sprites) ->
    @count = 100
    @speed = 7.0 / 100
    @interval = 250
    @health = 100
    @prize = 20
    @sprite = sprites.tank14

class Wave4 extends Wave
  constructor: (sprites) ->
    @count = 2
    @speed = 2.0 / 100
    @interval = 10000
    @health = 5000
    @prize = 500
    @sprite = sprites.mother

class Wave5 extends Wave
  constructor: (sprites) ->
    @count = 20
    @speed = 5.0 / 100
    @interval = 1000
    @health = 1000
    @prize = 100
    @sprite = sprites.tank1

class Wave6 extends Wave
  constructor: (sprites) ->
    @count = 20
    @speed = 10.0 / 100
    @interval = 1000
    @health = 1500
    @prize = 150
    @sprite = sprites.tankB1

class Wave7 extends Wave

  constructor: (sprites) ->
    @count = 10
    @speed = 10.0 / 100
    @interval = 1000
    @health = 5000
    @prize = 250
    @sprite = sprites.transport

class Wave8 extends Wave

  constructor: (sprites) ->
    @final = true


class Sprites

  constructor: (callback) ->
    await
      new MotherSprite(defer @mother)
      new BulletSprite(defer @bullet)
      new Explosion(defer @smallExplosion)
      new BigExplosion(defer @bigExplosion)
      new Factory2Sprite(defer @factory)
      new Factory2Anim(defer @mapFactory)
      new Artillery2Sprite(defer @artillery)
      new Artillery2Sprite(defer @mapArtillery)
      new FixedSprite('Buildings/Generator.bmp', 0, defer @generator)
      new HVAnimSprite('Buildings/Generator.bmp', [0..14], Misc.BUILDING_ANIM_INTERVAL, defer @mapGenerator)
      new FixedSprite('Buildings/Field.bmp', 2, defer @field)
      # TODO: sprite alignment for animation is incorrect
      new HVAnimSprite('Buildings/Field.bmp', [3,4,0,1,2,1,0,4,3], Misc.BUILDING_ANIM_INTERVAL, defer @mapField)
      new GrassSprite(0, defer @grassTopLeft)
      new GrassSprite(1, defer @grassTopMid)
      new GrassSprite(2, defer @grassTopRight)
      new GrassSprite(3, defer @grassMidLeft)
      new GrassSprite(4, defer @grassMidMid)
      new GrassSprite(5, defer @grassMidRight)
      new GrassSprite(6, defer @grassBottomLeft)
      new GrassSprite(7, defer @grassBottomMid)
      new GrassSprite(8, defer @grassBottomRight)
      new FixedSprite('Vehicles/Beast.bmp', 6, defer @beast)
      new FixedSprite('Vehicles/Tank1.bmp', 4, defer @tank1)
      new FixedSprite('Vehicles/TankB1.bmp', 4, defer @tankB1)
      new FixedSprite('Vehicles/Tank2.bmp', 4, defer @tank2)
      new FixedSprite('Vehicles/Tank5.bmp', 4, defer @tank5)
      new FixedSprite('Vehicles/Tank14.bmp', 4, defer @tank14)
      new FixedSprite('Vehicles/Tank14.bmp', 4, defer @tank14)
      new FixedSprite('Vehicles/Transprt.bmp', 4, defer @transport)
    callback(@)

class GameState
  constructor: (sprites, mapWidth, mapHeight) ->
    @sprites = sprites
    @mapWidth = mapWidth
    @mapHeight = mapHeight
    @wave = 0
    @nextWave = 1
    @waveReady = true
    @map = null
    @creeps = []
    @towers = []
    @bullets = []
    @lives = 30
    @money = 1000
    @paused = false
    @finished = false
    @pausedTime = 0
    @startTime = Misc.getTime()
    @updateLives()

  start: () ->
    @waveStart = @getGameTime() + 1*1000
    gameState = @
    setInterval (() -> gameState.updateGameTimer()), 1000

  getGameTime: () ->
    if @paused
      @pausedStart - @pausedTime - @startTime
    else
      currentTime = Misc.getTime()
      currentTime - @pausedTime - @startTime

  waveFinished: () ->
    @wave == @nextWave and @waveReady and @creeps.length == 0

  startWave: () ->
    if @wave < @nextWave and not @finished
      @waveReady = false
      @wave = @nextWave
      @waveStarted = @waveStart
      delete @waveStart
      Misc.displayMessage("Wave starting!")
      waveClass = eval('Wave' + @wave)
      wave = new waveClass(@sprites)
      if wave.final
        Misc.displayMessage "Game over! You won!"
      else
        @startWaveP(wave)

  startWaveP: (wave) ->
    path = [[0, @mapHeight / 2], [@mapWidth, @mapHeight / 2]]
    wave
    sprite = wave.sprite
    currentTime = @getGameTime()
    for i in [1..wave.count]
      creep = new Creep(@, sprite.clone(), wave.speed, wave.health, path, wave.prize)
      creep.id = i
      creep.startTime = currentTime + i * wave.interval
      creep.newCreep = true
      @creeps.push(creep)
    @oldFrameTime = currentTime
    @waveReady = true

  frameCreeps: (elapsed) ->
    mapContainer = @mapContainer
    aliveCreeps = []
    for creep in @creeps
      if not creep.active
        if creep.startTime <= @getGameTime()
          if creep.newCreep
            creep.newCreep = false
            creep.pos =
              x: creep.path[0][0]
              y: creep.path[0][1]
            creep.prevWayPoint = creep.path[0]
            creep.nextWayPoint = creep.path[1]
            creep.active = true
      if creep.active
        nextTarget = creep.nextWayPoint
        dx = nextTarget[0] - creep.prevWayPoint[0]
        dy = nextTarget[1] - creep.prevWayPoint[1]
        dist = Math.sqrt(dx * dx + dy * dy)
        ndx = dx / dist
        ndy = dy / dist
        creep.pos.x += creep.speed * ndx * elapsed
        creep.pos.y += creep.speed * ndy * elapsed
        if creep.pos.x > @mapWidth or creep.pos.y > @mapHeight
          @loseLife(1)
          creep.remove()
      if not creep.dead
        aliveCreeps.push(creep)
    @creeps = aliveCreeps

  shoot: (tower, creep) ->
    hit = () ->
      creep.updateHealth(creep.health - tower.damage)
    tower.lastFire = @getGameTime()
    bullet = new Bullet(@sprites.bullet.clone())
    bullet.targetPos = creep.pos
    bullet.duration = 100
    setTimeout hit, bullet.duration
    bullet.startTime = @getGameTime()
    bullet.startPos =
      x: tower.pos.x
      y: tower.pos.y
    bullet.pos =
      x: bullet.startPos.x
      y: bullet.startPos.y
    @bullets.push(bullet)

  rotateTower: (tower, creep) ->
    dx = tower.midX() - creep.midX()
    dy = tower.midY() - creep.midY()
    rad = Math.atan2(dy, dx) - tower.startRotation
    tower.moving = true
    tower.container.animateRotate tower.currentRotation, rad, 100, "swing", () ->
      tower.currentRotation = rad
      #if tower.sprite.setIndex?
      #  index = DirectionIndices.rad2index(rad)
      #  tower.sprite.setIndex(index)
      tower.moving = false

  animate: () ->
    if @paused
      gameState = @
      requestAnimationFrame(() -> gameState.animate())
      return
    @mapContainer.find(".dead").remove()
    for tower in @towers
      if not tower.moving and tower.target? and not tower.target.dead?
        @rotateTower(tower, tower.target)
    for creep in @creeps
      if creep.active and not creep.dead?
        if not creep.addedToMap?
          @mapContainer.append(creep.container)
          creep.addedToMap = true
        creep.container
          .css
            position: "absolute"
            left: creep.pos.x
            top: creep.pos.y
    for bullet in @bullets
      if not bullet.addedToMap?
        @mapContainer.append(bullet.container)
        bullet.addedToMap = true
      bullet.container
        .css
          position: "absolute"
          left: bullet.pos.x
          top: bullet.pos.y
    gameState = @
    requestAnimationFrame(() -> gameState.animate())

  frameBullets: () ->
    currentTime = @getGameTime()
    activeBullets = []
    for bullet in @bullets
      elapsed = (currentTime - bullet.startTime) / bullet.duration
      if elapsed <= 1.0
        ndx = bullet.targetPos.x - bullet.startPos.x
        ndy = bullet.targetPos.y - bullet.startPos.y
        bullet.pos.x = bullet.startPos.x + ndx * elapsed
        bullet.pos.y = bullet.startPos.y + ndy * elapsed
        activeBullets.push(bullet)
      else
        bullet.container.addClass("dead")
    @bullets = activeBullets

  dist: (tower, creep) ->
    dx = tower.midX() - creep.midX()
    dy = tower.midY() - creep.midY()
    dist = Math.sqrt(dx * dx + dy * dy)

  frameTowers: () ->
    currentTime = @getGameTime()
    for tower in @towers
      aliveCreeps = []
      for creep in @creeps
        if creep.active
          if @dist(tower, creep) <= tower.range
            if not tower.target? or tower.target.dead? or @dist(tower, tower.target) > tower.range
              tower.target = creep
            if currentTime - tower.lastFire > tower.fireRate
              @shoot(tower, tower.target)
          if creep.health > 0
            aliveCreeps.push(creep)
        else
          aliveCreeps.push(creep)
      @creeps = aliveCreeps

  pause: () ->
    @pausedStart = Misc.getTime()
    gameState.paused = true

  unpause: () ->
    @pausedTime += Misc.getTime() - @pausedStart
    gameState.paused = false

  frame: () ->
    if @paused
      return
    currentTime = @getGameTime()
    oldFrameTime = @oldFrameTime
    elapsed = currentTime - oldFrameTime
    @oldFrameTime = currentTime
    if @waveFinished()
      @nextWave += 1
      @waveStart = @getGameTime() + 3 * 1000
      delete @waveStarted
    #if @wave == @nextWave and @waveReady and @creeps.length > 0
    @frameBullets(elapsed)
    @frameCreeps(elapsed)
    @frameTowers(elapsed)

  updateGameTimer: () ->
    gameState = @
    currentTime = gameState.getGameTime()
    seconds = Math.round((gameState.waveStart - currentTime) / 1000)
    if seconds >= 0
      $("#gametimer").html("Next wave in " + seconds + " seconds")
    else
      if gameState.waveStarted?
        d = new Date(currentTime - gameState.waveStarted)
        $("#gametimer").html("Wave timer: #{d.getMinutes()}:#{d.getSeconds()}")
      else
        gameState.startWave()

  updateLives: () ->
    if @lives < 0
      Misc.displayError("Game over! You lost!")
      @finished = true
    else
      $("#lives").html("Lives left: #{@lives}")

  buy: (buyMenu, [x, y]) ->
    gameState = @
    buyActive = buyMenu.active
    buyItem = buyMenu.active.buyItem
    if gameState.money >= buyItem.cost
      gameState.money -= buyItem.cost
      buyMenu.updateMoney(gameState.money)
      sprite = buyItem.createInstance()
      [width, height] = [buyActive.cursorImage.width(), buyActive.cursorImage.height()]
      buyItem = buyActive.buyItem
      tower = new Tower(gameState, [x, y, width, height], buyItem.startRotation, sprite, buyItem.fireRate, buyItem.damage, buyItem.range)
      @mapContainer.append(tower.container)
      gameState.towers.push(tower)
    else
      Misc.displayError("Not enough money!")

  loseLife: (lives) ->
    @lives -= lives
    @updateLives()

FormulaEditor = (args) ->
  _self = this
  _editor = new Slick.Editors.Text(args)
  _selector = undefined
  $.extend this, _editor

  init = ->
    # register a plugin to select a range and append it to the textbox
    # since events are fired in reverse order (most recently added are executed first),
    # this will override other plugins like moverows or selection model and will
    # not require the grid to not be in the edit mode
    _selector = new Slick.CellRangeSelector()
    console.log("selector", _selector)
    _selector.onCellRangeSelected.subscribe _self.handleCellRangeSelected
    args.grid.registerPlugin _selector
    return

  @destroy = ->
    _selector.onCellRangeSelected.unsubscribe _self.handleCellRangeSelected
    args.grid.unregisterPlugin _selector
    _editor.destroy()
    return

  @handleCellRangeSelected = (e, args) ->
    _editor.setValue _editor.getValue() + args.grid.getColumns()[args.range.fromCell].name + args.range.fromRow + ":" + args.grid.getColumns()[args.range.toCell].name + args.range.toRow
    return

  init()
  return


class CoffeeMain
  constructor: () ->
    @

  loadGame: () ->
    main = $("#maincontent")
    main.empty()
    #main.css("height", "100%")
    main.css
      height: "800px"
    sidebar = $("#sidebar")
    Misc.addRotateAnimateToJQuery()
    
    # should be divisible by 20 because of map tiles
    mapWidth = Math.floor(main.width() / 20) * 20
    mapHeight = 800 # Math.floor(main.height() / 20) * 20
    await
      new Sprites(defer sprites)
    gameState = new GameState(sprites, mapWidth, mapHeight)
    window.gameState = gameState # for debugging with js console
    gameState.start()

    mapContainer = HTML.div()
      .css('width', mapWidth)
      .css('height', mapHeight)
    main.append(mapContainer)

    map = new Map(gameState, mapWidth, mapHeight)
    buyMenu = new BuyMenu(gameState)

    gameState.mapContainer = mapContainer
    gameState.winPrize = (prize) ->
      # TODO: animate money rising up from corpse
      gameState.money += prize
      buyMenu.updateMoney(gameState.money)
   
    for canvas in map.terrain
      mapContainer.append(canvas)
    
    buyMenuDOM = $("#buyMenu")
    buyMenuDOM.empty()
    buyMenuDOM.append(buyMenu.container)
    
    # Logic to handle buying items
    buyMenu.updateMoney(gameState.money)
    buyMenu.setupMouseHandlers mapContainer, gameState

    $("#startNext").click () ->
      gameState.waveStart = gameState.getGameTime()
      gameState.startWave()

    $("#pause").click () ->
      if gameState.paused
        gameState.unpause()
        Misc.displayMessage "Game started!"
      else
        gameState.pause()
        Misc.displayMessage "Game paused!"

    setInterval (() -> gameState.frame()), 10
    requestAnimationFrame(() -> gameState.animate())

  todo: () ->
    main = $("#maincontent")
    main.empty()
    todo = HTML.ul()
    main.append(todo)
    todoItems = [
      'let tower / creep distance computation be from the closest corner',
      'fix click responsiveness in placing tower',
      'rotate bullets',
      'improve tower rotation. use sprites, relative rotation',
      'rotate tower randomly when no creeps around',
      'animate money rising up from dead creep',
      'toggle range display overlay for towers',
      'create map editor',
      'click tower to see properties and statistics',
      'DPS overlay',
      'disallow multiple towers in same location',
      'add support for AOE damage, add some towers'
    ]
    for item in todoItems
      todo.append(HTML.li(item))

  loadSprites: (callback) ->
    main = $("#maincontent")
    main.empty()
    if not @sprites?
      @sprites = {}
      await
        for sprite, i in spritePaths.split('\n')
          console.log("loading", sprite)
          new SelectSpriteAll(sprite, 0, (defer @sprites[sprite]))
    json = {}
    for i,sprite of @sprites
      main.append(sprite.container)
      sprite.reattachHandlers()
      for c in sprite.canvases
        $(c).addClass("selectSprite")
      json[sprite.imgsrc] = sprite.json
    data = JSON.stringify(json)
    url = 'data:text/json;charset=utf8,' + encodeURIComponent(data)
    callback()
    #window.open(url, '_blank')
    #window.focus()

  loadSprites3: () ->
    main = $("#maincontent")
    main.empty()
    sprites = []
    await
      for sprite, components of spriteData
        texture = new Image()
        sprites[sprite] =
          image: texture
          components: components.components
        texture.onload = (defer())
        texture.src = sprite
    for sprite,content of sprites
      console.log(content.components)
      for component,i in content.components
        c = HTML.canvas()
        context = c[0].getContext("2d")
        console.log(component)
        [width, height] = [component.maxX - component.minX, component.maxY - component.minY]
        context.drawImage content.image, component.minX, component.minY, width, height, 0, 0, width, height
        main.append(c)

  newMapEditor: () ->
    main = $("#maincontent")
    main.empty()

    mapGridDiv = HTML.div '',
      id: "mapGrid"
    mapGridDiv.css
      top: "20px"
      height: "800px"
    main.append(mapGridDiv)

    grid = undefined
    columns = []

    tileWidth = 20
    tileHeight = tileWidth
    mapWidthTiles = 100
    mapHeightTiles = 100

    spriteMap = {}
    for line in mapData.split('\n')
      if line.indexOf('=') >= 0
        [char, sprite, index] = line.split('=')
        spriteMap[char] =
          path: sprite
          sprite: @sprites[sprite]
          index: index
    renderTile = (cellNode, row, dataContext, colDef) ->
      c = $(cellNode).text()
      spritePath = spriteMap[c].path
      sprite = spriteMap[c].sprite.getFixedSprite(spriteMap[c].index)
      $(cellNode).append(sprite.container)
      Misc.move sprite.container, [0, 0]
      $(cellNode).css
        width: sprite.canvas.width + "px"
        height: sprite.canvas.height + "px"
        padding: "0px"
        margin: "0px"
        border: "0px"
      $(cellNode).parent().css
        border: "0px"
        margin: "0px"
        padding: "0px"


    for i in [0..mapWidthTiles]
      columns.push
        id: "" + i
        name: "" + i
        field: i
        editor: FormulaEditor #Slick.Editors.Text
        asyncPostRender: renderTile
        width: tileWidth
        minWidth: tileWidth

    options =
      rowHeight: 20
      defaultColumnWidth: 20
      enableCellNavigation: true
      enableColumnReorder: false
      editable: true
      enableAsyncPostRender: true
      asyncPostRenderDelay: 1
      enableAddRow: true
      enableCellNavigation: true
      autoEdit: false

    data = []
    i = 0
    while i < mapHeightTiles
      row = {}
      for j in [0..mapWidthTiles]
        row[j] = 'e'
      data[i] = row
      i++
    grid = new Slick.Grid(mapGridDiv, data, columns, options)
    grid.setSelectionModel new Slick.CellSelectionModel()
    grid.registerPlugin new Slick.AutoTooltips()

    # set keyboard focus on the grid
    grid.getCanvasNode().focus()
    copyManager = new Slick.CellCopyManager()
    grid.registerPlugin copyManager

    copyManager.onPasteCells.subscribe (e, args) ->
      throw "This implementation only supports single range copy and paste operations"  if args.from.length isnt 1 or args.to.length isnt 1
      from = args.from[0]
      to = args.to[0]
      val = undefined
      i = 0

      while i <= from.toRow - from.fromRow
        j = 0

        while j <= from.toCell - from.fromCell
          if i <= to.toRow - to.fromRow and j <= to.toCell - to.fromCell
            val = data[from.fromRow + i][columns[from.fromCell + j].field]
            data[to.fromRow + i][columns[to.fromCell + j].field] = val
            grid.invalidateRow to.fromRow + i
          j++
        i++
      grid.render()
      return

    grid.onAddNewRow.subscribe (e, args) ->
      item = args.item
      column = args.column
      grid.invalidateRow data.length
      data.push item
      grid.updateRowCount()
      grid.render()


  mapEditor: () ->
    main = $("#maincontent")
    main.empty()
    
    if @map?
      map = @map
    else
      map = {}
      map.div = HTML.div()
      map.text = HTML.textarea()

    map.div.css
      width: '1200px'
      height: '800px'

    main.append(map.text)
    main.append(map.div)

    sprites = @sprites

    render = (mapdiv, text) ->
      tiles = {}
      previous = $(mapdiv).find(".tile")
      for prev in previous
        prev = $(prev)
        xy = prev.data "x,y"
        tiles[xy] = prev

      spriteMap = {}
      y = 0
      keepTiles = {}
      for line in text.split('\n')
        if line.indexOf('=') >= 0
          [char, sprite, index] = line.split('=')
          spriteMap[char] =
            path: sprite
            sprite: sprites[sprite]
            index: index
        else
          x = 0
          for c in line
            if c == ' '
              continue
            xs = x * 20
            ys = y * 20
            prev = tiles[x + "," + y]
            #console.log("prev", prev)
            if prev? and prev.data("imgsrc") == spriteMap[c].path and prev.data("index") == spriteMap[c].index
              keepTiles[x + "," + y] = true
              #console.log("reusing tile")
            else
              $(prev).remove()
              spritePath = spriteMap[c].path
              sprite = spriteMap[c].sprite.getFixedSprite(spriteMap[c].index)
              mapdiv.append(sprite.container)
              Misc.move sprite.container, [xs, ys]
              sprite.container.addClass("tile")
              sprite.container.css
                opacity: "50%"
              sprite.container.data "x,y", x + "," + y
              sprite.container.data "imgsrc", spriteMap[c].path
              sprite.container.data "index", spriteMap[c].index
            x += 1
          y += 1
      for prev in previous
        tile = $(prev)
        if not keepTiles[tile.data("x,y")]?
          tile.remove()

    map.text.css
      # http://stackoverflow.com/questions/2032652/how-do-i-get-an-html-text-area-with-monospaced-text-using-css
      "font-family": "Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace"
      position: "absolute"
      top: 0
      left: 0
      "z-index": 1
      "background-color": "transparent"
      width: map.div.width()
      height: map.div.height()
      "font-weight": "bold"
    map.text.val(mapData)
    map.text.on "input propertychange", () ->
      console.log(map.text.val())
      render(map.div, map.text.val())
    render(map.div, map.text.val())

    sprite = $("#selectedSprite").data("sprite")
    index = $("#selectedSprite").data("index")
    cursor = undefined
    map.div.on "mousemove", (event) ->
      if sprite?
        map.div.css
          cursor: "none"
        if not cursor?
          newSprite = sprite.getFixedSprite(index)
          cursor = newSprite.container
        cursor.css
          opacity: "0.5"
        map.div.append(cursor)
        [x, y] = [event.pageX - map.div.offset().left, event.pageY - map.div.offset().top]
        [x, y] = Misc.snapToTerrain(x, y)
        Misc.move cursor, [x, y]

    map.div.click (event) ->
      console.log("adding it", sprite, index)
      c = sprite.getFixedSprite(index)
      map.div.append(c.container)
      [x, y] = [event.pageX - map.div.offset().left, event.pageY - map.div.offset().top]
      [x, y] = Misc.snapToTerrain(x, y)
      Misc.move c.container, [x, y]
        
    buyMenu = $("#buyMenu")
    buyMenu.empty()

  main: () ->
    console.log("main")
    main = @
    Misc.addons()

    urlViewMap =
      "#game": () -> main.loadGame()
      "#todo": () -> main.todo()
      "#sprites": () -> main.showSprites()
      "#mapEditor": () -> main.newMapEditor()
          
    await @loadSprites(defer())
    for url, view of urlViewMap
      do (url, view) ->
        clickHandler = () ->
          $(this).parent().parent().find("li").removeClass("active")
          $(this).parent().addClass("active")
          view()
        menuItem = $('a[href*="' + url + '"]')
        menuItem.click clickHandler
        if location.href.endsWith(url)
          menuItem.trigger "click"

window.CoffeeMain = new CoffeeMain()
